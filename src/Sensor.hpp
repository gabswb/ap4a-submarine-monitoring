/**
 * @author Gabriel_SCHWAB
 * @file Sensor.hpp
 * @date 27/09/2021
 * @Brief Description : abstract template class which have attributes and methods to simulate a sensor
 */

//
//Define guards
#ifndef SENSOR_HPP
#define SENSOR_HPP

#include <string>
#include <random>



/**
 * @class Sensor
 * @brief This is an abstract class which simulate the operation of a sensor in a submarine
 */
template <class T>
class Sensor
{

public :


	Sensor<T>():
		m_sensorType(),m_unit(),m_frequency(){}

	/**
	 * @brief constructor for the derived classes
	 * @param sensorType_p is a string for the type of the sensor
	 * @param unit_p is the unit of the data generated by the sensor
	 * @param frequency_p is the frequency of the display in the console and the log in the file
	 */
	Sensor<T>(std::string sensorType_p, std::string unit_p, int frequency_p):
		m_sensorType(sensorType_p),m_unit(unit_p),m_frequency(frequency_p){}

	Sensor<T>(const Sensor& sensor_p):
		m_sensorType(sensor_p.m_sensorType),m_unit(sensor_p.m_unit),m_frequency(sensor_p.m_frequency){}

	virtual ~Sensor<T>(){}

	Sensor& operator=(const Sensor& sensor_p)
	{
		this->m_sensorType=sensor_p.m_sensorType;
		this->m_unit=sensor_p.m_unit;
		this->m_frequency=sensor_p.m_frequency;

		return *this;
	}


	/**
	 * @brief getter to access to the value generate by @aleaGenVal
	 * @param generator_p is the random engine used
	 * @return the value generated by @aleaGenVal
	 */
	/**
	 * @brief getter to access to the value generate by @aleaGenVal
	 * @param pGenerator_p is a random engine
	 * @return template type, either a int a float or a bool
	 */
	T  getData(std::default_random_engine* pGenerator_p)
	{
		return aleaGenVal(pGenerator_p);
	}


	/**
	 * @brief getter to access to the attribute m_sensorType
	 * @return the attribute m_sensorType
	 */
	std::string getSensorType()
	{
		return this->m_sensorType;
	}
	/**
	 * @brief getter to access to the value of the attribute m_unit
	 * @return	the attribute m_unit
	 */
	std::string getUnit()
	{
		return this->m_unit;
	}

	/**
	 * @brief getter to access to the value of the attribute m_frequency
	 * @return the value of the attribute m_frequency
	 */
	int getFrequency()
	{
		return this->m_frequency;
	}


protected :

	std::string m_sensorType; ///<string which describe what type of data is capture by the sensor
	std::string m_unit; ///< unit of the data return by the sensor

	int m_frequency;///< frequency of the data generation

	/**
	 * @brief method which simulate the data captured by the sensor
	 * @param generator_p is the random engine
	 * @return a value which simulate the value captured by the sensor
	 */

	virtual T aleaGenVal(std::default_random_engine* pGenerator_p)=0;

};

template class Sensor<int>;
template class Sensor<bool>;
template class Sensor<float>;

#endif /* SENSOR_HPP */
